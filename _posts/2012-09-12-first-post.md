---
title: First Post
author: Chris
layout: post
---


## 그래프 탐색 알고리즘
(그래프의 모든 노드를 방문)

# 1. 깊이 우선 탐색(DFS, Depth First Search)
    - 현재 정점에서 갈 수 있는 점들 중, 한 곳을 우선적으로 끝까지 탐색
    - 방법 : 스택이나 재귀함수로 구현
    - 단순 검색에 있어서는 BFS보다 느리지만 백트래킹, 미로 생성 알고리즘에 많이 쓰임
    - 찾는 노드가 있는 루트 이외의 무한 루트에 빠졌을 때 거기서 헤어 나오지 못함
    - 저장 공간이 많이 필요하지 않아서(재귀로 구현했을 경우) 모든 경우의 수 찾기에 적합

    *** 참고해야할 점
    - 방문했던 정점을 재 탐색 하지 않기위해, 따로 배열을 만들어서 방문한 곳인지 체크해야합니다.
    - 완전 탐색 입니다.
    - 트리에서 최단 거리 탐색 가능합니다.
    - 가중치 및 비가중치 그래프에서는 거의 사용되지 않습니다.(불가능하다, 가능은하나... 와 같은 여러 의견들이 있습니다)

> 주어진 무방향 그래프 G = (V, E)가 있을때 정점 i에서 DFS수행하는 방법은 아래와 같습니다.  
> 정점 i를 방문한다.  
> 정점 i에 인접한 정점 중에서 아직 방문하지 않은 정점이 있으면 이 정점을 모두 stack에 저장한다.  
> 스택에서 정점을 삭제하여 새로운 i를 설정하고 다시 단계 1부터 수행한다.  
> 스택이 공백이 되면 연산을 종료한다.  
> 단, 이 연산을 구하기 위해서는 정점들의 방문 여부를 표시해 두는 것이 필요하다. 이는 배열 visited[n]을 사용하여 아래와 같이 표기한다.
> visited[i] = true // 방문, visited[i] = false // 미방문  

> 1) DFS 수행과정
> 무방향 그래프의 깊이우선탐색 결과<br>
> <span class="image center"><img src="{{ 'assets/images/dfs_1.png' | relative_url }}" alt="" /></span><br>

> visited[] 배열을 보면 모든 정점의 방문 여부를 false로 하여 방문하지 않은 것을 표시하며 stack[]에는 순회를 시작할 정점을 넣어둠<br>
> <span class="image center"><img src="{{ 'assets/images/dfs_2.png' | relative_url }}" alt="" /></span><br>




```java
public class DFS {
  public static void depthFS(int[][] graph, int vertex){
    Stack stack = new Stack(100);
    boolean[] visited = new boolean[graph.length];

    for(int i=0; i<visited.length; i++){
      visited[i] = false;
    }
    stack.push(vertex);
    while(!stack.isEmpty()) {
      int v = stack.pop();
      if(visited[v] == false) {
        System.out.print(v + "  ");
        visited[v] = true;
        for(int i = graph[v].length-1; i >= 0; i--) {
          if(graph[v][i] == 1) {
            if(visited[i] == false) {
              stack.push(i);
            }
          }
        }
      }
    }
  }
  public static void main(String[] args) {
    int[][] graph = {
                    {0,1,1,1,0,0,0},
                    {1,0,0,0,1,0,0},
                    {1,0,0,0,1,1,0},
                    {1,0,0,0,0,1,0},
                    {0,1,1,0,0,0,1},
                    {0,0,1,1,0,0,1},
                    {0,0,0,0,1,1,0}
                    };
    depthFS(graph,0);
  }
}
```

# 2. 너비 우선 탐색(BFS)
    - 현재 정점에 연결된 가까운 점들부터 탐색
    - 방법 : 큐를 이용해서 구현
    - 검색에 유용, DFS처럼 무한 루프에 빠질 위험성이 적음
    - DFS와 다르게 최단 경로 찾아낼 수 있음
    - 공간 복잡도가 지수적으로 증가하기 때문에 오버플로가 쉽게 됨

    *** 참고해야할 점

    - 방문했던 곳을 재 방문 하지 않기위해, 따로 배열을 만들어서 체크해야합니다.
    - 완전 탐색입니다.
    - 트리에서 최단거리 탐색이 가능합니다.
    - 비가중치 그래프에서 최단거리 탐색이 가능합니다. (다익스트라보다 효율이 좋다고 합니다.)
    - 가중치 그래프에서는 잘 사용되지 않습니다.


# 3. 휴리스틱(heuristic) 탐색
    - BFS에서 발전된 방식으로 휴리스틱의 방법을 이용해서 최선의 길 선택
    - 보통 힙으로 구현된 우선순위 큐(priority queue) 사용
     (휴리스틱: 시간이나 정보가 불충분하여 합리적인 판단을 할 수 없거나 굳이 체계적이고 합리적인 판단을 할 필요가 없는 상황에서
       사람들이 신속하게 사용하는 어림짐작)


# 4. 백트래킹(backtracking)
    - 왔던 길을 되추적하는 것을 의미
    - 한 루트를 쭉 검사하고 되돌아와서 다른 루트를 검사하는 DFS와 비슷

    - 깊이 우선 탐색에서는 한 루트를 끝까지 들여다보고 정답이 없을 시 처음으로 되돌아와서 다른 루트를 검사하는데,
    이 과정에서 깊은 탐색에는 유용하지만 해당 루트에 답이 없을 경우 많은 시간을 허비하게됨
    그래서 시간을 단축시키기 위해 특정 루트에 들어가기 전에 이 루트가 유망한지(정답이 있을 확률이 높은지)
    유망하지 않은지(정답이 있을 확률이 낮은지)를 판단하여 이 루트를 검사 할지 말지 판단하는데, 이를 가지치기라고 함
    - 루트를 참색하기 전에 최선의 길을 미리 판단한다는 휴리스틱 탐색과 비슷한 방법
